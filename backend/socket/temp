const express = require("express");
const app = express();
const { Server } = require("socket.io");
const http = require("http");
const cors = require("cors");
const getWords = require("../helper/getWords.js");
app.use(
    cors({
        origin: "http://localhost:5173",
    })
);
const server = http.createServer(app);
const io = new Server(server, {
    cors: {
        origin: "http://localhost:5173",
    },
});

const calcuatePointsForGuess = () => {
    return 1;
};
const calculatePointsForDraw = () => {
    return 1;
};

const roomMembers = {};
const roomConditions = {};

//initial room conditions
//                 wordChosen: false,
//                 players: null,
//                 rounds: null,
//                 currentRound: null,
//                 words: null,
//                 drawTime: null,
//                 hints: [],
//                 currentlyDrawing: null,
//                 correctAns: null,
//                 roomOwner: socket.id,
//                 isGameStarted: false,
//                 timerStartTime: null,
/*
{
   wordChosen: false,
   players:count of max possible players in room,
   rounds:max possible rounds,
   currentRound:marks the current round
   words:no of words to be sent to drawer
   hints:count of max possible hints to be given
   drawTime: total time to draw the word
   currentlyDrawing:index of the currently drawing room member
   correctAns:correct ans of the drawing
   roomOwner:id of room owner
   isGameStarted:false
   showWaitingScreen:false
}
*/

io.on("connection", (socket) => {
    console.log(`Socket ${socket.id} connected`);
    //creating room
    // =========================================================================================================
    socket.on("create-room", ({ name, room }) => {
        try {
            // created new room entry in  roomMembers object
            roomMembers[room] = [
                {
                    name: name,
                    id: socket.id,
                    points: 0,
                    guessedCorrectAns: false,
                },
            ];
            // creating an entry for room conditons for newly created room
            roomConditions[room] = {
                wordChosen: false,
                players: null,
                rounds: null,
                currentRound: null,
                words: null,
                drawTime: null,
                hints: [],
                currentlyDrawing: null,
                correctAns: null,
                roomOwner: socket.id,
                isGameStarted: false,
                timerStartTime: null,
                showWaitingScreen: false,
            };
            socket.join(room);
        } catch (err) {
            socket.emit("error", err.message);
        }
    });
    // =========================================================================================================
    // joining the created room
    socket.on("join-room", ({ name, room }) => {
        try {
            if (!roomMembers[room] || !roomConditions[room]) {
                throw new Error("Room doesn't exist");
            }
            roomMembers[room].push({
                name: name,
                id: socket.id,
                points: 0,
                guessedCorrectAns: false,
            });
            socket.join(room);

            // notifying everyone that someone joined
            io.to(room).emit("recieve-message", {
                name: name,
                category: "joined",
                message: "joined the room",
            });

            // updating room conditions to late joinees
            const whoIsDrawing =
                roomMembers[room][roomConditions[room]?.currentlyDrawing - 1];

            // updating game condtitions when a user joins the game
            socket.emit("update-game-conditions", {
                wordChosen: roomConditions[room]?.wordChosen,
                currentlyDrawing: whoIsDrawing,
                totalRounds: roomConditions[room]?.rounds,
                totalDrawTime: roomConditions[room]?.drawTime,
                currentRound: roomConditions[room]?.currentRound,
                currentWordLength:
                    roomConditions[room]?.correctAns?.length || 0,
                roomOwner: roomConditions[room].roomOwner,
                isGameStarted: roomConditions[room].isGameStarted,
                showWaitingScreen: roomConditions[room].showWaitingScreen,
            });
            if (
                roomConditions[room].isGameStarted === true &&
                roomConditions[room].timerStartTime != null
            ) {
                console.log("Sending timer for late guys");
                const timeLeft =
                    roomConditions[room].drawTime -
                    (Date.now() - roomConditions[room].timerStartTime) / 1000;
                socket.emit("start-timer-late", timeLeft);
            }
        } catch (err) {
            socket.emit("error", { message: err.message });
        }
    });

    // =========================================================================================================
    // show waiting screen
    socket.on("show-waiting-screen", ({ room }) => {
        roomConditions[room].showWaitingScreen = true;
        socket.to(room).emit("render-waiting-screen", {
            data: true,
            category: "choosing-word",
        });
    });

    // =========================================================================================================
    //setting game rules
    socket.on("set-game-rules", (data) => {
        roomConditions[data.room] = {
            ...roomConditions[data.room],
            wordChosen: false,
            players: data.gameRules.Players,
            rounds: data.gameRules.Rounds,
            currentRound: 1,
            words: data.gameRules.WordCount,
            drawTime: data.gameRules.DrawTime,
            hints: data.gameRules.Hints,
            currentlyDrawing: 1,
            correctAns: null,
            isGameStarted: true,
        };
        if (!roomMembers[data.room]) {
            console.log("Room DNE");
            return;
        }
        for (let i = 0; i < roomMembers[data.room].length; i++) {
            roomMembers[data.room][i].points = 0;
        }
        const whoIsDrawing =
            roomMembers[data.room][
                roomConditions[data.room]?.currentlyDrawing - 1
            ];
        // this is update after room owner has created the room
        io.to(data.room).emit("update-game-conditions", {
            wordChosen: roomConditions[data.room].wordChosen,
            currentlyDrawing: whoIsDrawing,
            totalRounds: roomConditions[data.room].rounds,
            totalDrawTime: roomConditions[data.room].drawTime,
            currentRound: roomConditions[data.room].currentRound,
            currentWordLength:
                roomConditions[data.room]?.correctAns?.length || 0,
            roomOwner: roomConditions[data.room]?.roomOwner,
            isGameStarted: true,
            showWaitingScreen: whoIsDrawing.id == socket.id ? false : true,
            waitScreenMessage: "round",
        });
        io.emit("recieve-connected-users", roomMembers[data.room]);
        if (roomConditions[data.room]) {
            const myWord = getWords(roomConditions[data.room]?.words);
            socket.emit("send-words", myWord);
        } else {
            socket.emit("error", { message: "Unexpected error occured" });
        }
    });

    // sending words to choose
    // socket.on("give-words", ({ room }) => {
    //     console.log("I have been called");
    //     if (roomConditions[room]) {
    //         const myWord = getWords(roomConditions[room]?.words);
    //         socket.emit("send-words", myWord);
    //     } else {
    //         socket.emit("error", { message: "Unexpected error occured" });
    //     }
    // });
    socket.on("send-answer", ({ word, room }) => {
        if (room && roomConditions[room] && roomConditions[room]) {
            //settting up room conditions
            roomConditions[room].correctAns = word;
            roomConditions[room].wordChosen = true;
            roomConditions[room].isGameStarted = true;
            const whoIsDrawing =
                roomMembers[room][roomConditions[room]?.currentlyDrawing - 1];
            // sending updated room conditions to all users
            io.to(room).emit("update-game-conditions", {
                wordChosen: true, //This is what i have to change other things are as it is
                currentlyDrawing: whoIsDrawing,
                totalRounds: roomConditions[room].rounds,
                totalDrawTime: roomConditions[room].drawTime,
                currentRound: roomConditions[room].currentRound,
                currentWordLength:
                    roomConditions[room]?.correctAns?.length || 0,
                isGameStarted: true,
                showWaitingScreen: true,
            });
            // sending message for timer
            io.to(room).emit("start-timer");
            io.to(room).emit("show-round");
            // setting a timer to accept answers
            roomConditions[room].timerStartTime = Date.now();

            // Timer
            // const timer = setTimeout(() => {
            //     let roundChanged = false;
            //     roomConditions[room].isGameStarted = false;
            //     roomConditions[room].timerStartTime = null;
            //     io.to(room).emit("recieve-message", {
            //         // iss part main problem hai
            //         message: `Correct answer was ${roomConditions[room]?.correctAns}`,
            //         category: "correct-ans",
            //     });
            //     // setting everyone's brush state to original
            //     io.to(room).emit("recieve-updated-brush-state", {
            //         lineWidth: 2,
            //         strokeStyle: "black",
            //     });
            //     //
            //     roomConditions[room].correctAns = null;
            //     roomConditions[room].wordChosen = false;
            //     const membersSize = roomMembers[room].length;
            //     const currentlyDrawingIndex =
            //         roomConditions[room]?.currentlyDrawing;
            //     if (currentlyDrawingIndex == membersSize) {
            //         const currentRoundValue =
            //             roomConditions[room]?.currentRound;
            //         // game over condition
            //         if (currentRoundValue == roomConditions[room]?.rounds) {
            //             console.log("game over");
            //             io.to(room).emit("game-over");
            //         } else {
            //             console.log("Changing the round");
            //             roomConditions[room].currentRound =
            //                 roomConditions[room]?.currentRound + 1;
            //             roomConditions[room].currentlyDrawing = 1;
            //             roundChanged = true;
            //         }
            //     } else {
            //         console.log("Changing the currently drawer");
            //         roomConditions[room].currentlyDrawing =
            //             roomConditions[room].currentlyDrawing + 1;
            //     }
            //     const whoIsDrawing =
            //         roomMembers[room][
            //             roomConditions[room]?.currentlyDrawing - 1
            //         ];
            //     // console.log("Room conditions", roomConditions[room]);
            //     for (let i = 0; i < roomMembers[room].length; i++) {
            //         roomMembers[room][i].guessedCorrectAns = false;
            //     }
            //     io.to(room).emit("recieve-connected-users", roomMembers[room]);

            //     io.to(room).emit("update-game-conditions", {
            //         wordChosen: false, //This is what i have to change other things are as it is
            //         currentlyDrawing: whoIsDrawing,
            //         totalRounds: roomConditions[room].rounds,
            //         totalDrawTime: roomConditions[room].drawTime,
            //         currentRound: roomConditions[room].currentRound,
            //         currentWordLength:
            //             roomConditions[room]?.correctAns?.length || 0,
            //         showWaitingScreen: roundChanged,
            //         waitScreenMessage: "round",
            //     });

            //     clearTimeout(timer);
            // }, roomConditions[room].drawTime * 1000);
        } else {
            socket.emit("error", { message: "Unexpected error occured" });
        }
    });

    // asking for results
    socket.on("ask-for-result", (room) => {
        // console.log("Recieved event for asking for result");
        console.log("Results", roomMembers[room]);
        socket.emit("get-results", roomMembers[room]);
    });
    //drawing events
    socket.on("drawing-data", ({ x, y, room }) => {
        io.to(room).emit("draw-on-screen", { x: x, y: y });
    });
    socket.on("clear-clicked", ({ room }) => {
        io.to(room).emit("clear", null);
    });
    socket.on("mouse-down", ({ x, y, room }) => {
        io.to(room).emit("handle-mouse-down", { x: x, y: y });
    });
    socket.on("mouse-up", ({ room }) => {
        io.to(room).emit("handle-mouse-up", null);
    });

    socket.on("update-brush-state", ({ data, room }) => {
        io.to(room).emit("recieve-updated-brush-state", data);
    });
    // connected users

    // messages
    socket.on("message", ({ data, room, name }) => {
        console.log("recieved msg");
        if (roomConditions[room].wordChosen) {
            if (data == roomConditions[room]?.correctAns) {
                const index = roomMembers[room].findIndex((member) => {
                    return member.id == socket.id;
                });
                if (
                    socket.id !=
                        roomMembers[room][
                            roomConditions[room].currentlyDrawing - 1
                        ].id &&
                    index != undefined &&
                    roomMembers[room][index].guessedCorrectAns == false
                ) {
                    roomMembers[room][index].points =
                        roomMembers[room][index].points +
                        calcuatePointsForGuess();
                    roomMembers[room][index].guessedCorrectAns = true;
                    io.to(room).emit("recieve-message", {
                        name: name,
                        message: "Guessed the correct answer",
                        category: "correct-ans",
                    });
                    // console.log(roomMembers[room]);
                    io.to(room).emit(
                        "recieve-connected-users",
                        roomMembers[room]
                    );
                } else {
                    socket.emit("recieve-message", {
                        name: name,
                        message: data,
                        category: "message",
                    });
                }
            } else {
                io.to(room).emit("recieve-message", {
                    name: name,
                    message: data,
                    category: "message",
                });
            }
        } else {
            io.to(room).emit("recieve-message", {
                name: name,
                message: data,
                category: "message",
            });
        }
    });
    // getting all connected users
    socket.on("get-connected-users", (room) => {
        if (roomMembers[room]) {
            io.to(room).emit("recieve-connected-users", roomMembers[room]);
        } else {
            console.log("error here");
            socket.emit("error", { message: "Error finding the room" });
        }
    });

    // handling errors
    socket.on("connect_error", (err) => {
        console.error("Connection error:", err);
    });
    socket.on("connect_timeout", () => {
        console.error("Connection timeout");
    });
    socket.on("error", (err) => {
        console.error("Socket error:", err);
    });

    //disconnect
    socket.on("disconnect", () => {
        console.log(`Socket ${socket.id} disconnected `);
        for (const room in roomMembers) {
            const memberIndex = roomMembers[room].findIndex(
                (member) => member.id === socket.id
            );
            console.log(memberIndex);
            if (memberIndex !== -1) {
                const removedMember = roomMembers[room].splice(
                    memberIndex,
                    1
                )[0];
                const removedMemberName = removedMember.name;
                if (roomMembers[room].length === 0) {
                    delete roomMembers[room];
                    delete roomConditions[room];
                } else {
                    console.log("calling these");
                    io.to(room).emit(
                        "recieve-connected-users",
                        roomMembers[room]
                    );
                    io.to(room).emit("recieve-message", {
                        name: removedMemberName,
                        message: `${removedMemberName} left the room`,
                        category: "left",
                    });
                }
            }
        }
    });
});

module.exports = { app, server };
